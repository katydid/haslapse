-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A haskell implementation of Katydid
--   
--   A haskell implementation of Katydid
--   
--   This includes:
--   
--   <ul>
--   <li>Relapse, a validation Language</li>
--   <li>Parsers for JSON, XML and an abstraction for trees</li>
--   </ul>
--   
--   You should only need the following modules:
--   
--   <ul>
--   <li>The Relapse module is used for validation.</li>
--   <li>The Json and XML modules are used to create Json and XML trees
--   that can be validated.</li>
--   </ul>
--   
--   If you want to implement your own parser then you can look at the
--   Parsers module
@package katydid
@version 0.3.0.0


-- | This module describes the abstract tree that can be validated by
--   Relapse.
--   
--   The JSON and XML parsers both are both versions of this type class.
module Parsers

-- | Tree is the type class that should be implemented by a katydid parser.
--   This is implemented by the Json and XML parser.
class Tree a
getLabel :: Tree a => a -> Label
getChildren :: Tree a => a -> [a]

-- | Label is a tagged union of all possible value types that can returned
--   by a katydid parser: String, Int, Uint, Double, Bool and Bytes.
data Label
String :: Text -> Label
Int :: Int -> Label
Uint :: Word -> Label
Double :: Double -> Label
Bool :: Bool -> Label
Bytes :: ByteString -> Label
instance Control.DeepSeq.NFData Parsers.Label
instance GHC.Generics.Generic Parsers.Label
instance GHC.Classes.Ord Parsers.Label
instance GHC.Classes.Eq Parsers.Label
instance GHC.Show.Show Parsers.Label


-- | This module contains the Json Parser.
module Json

-- | decodeJSON returns a JsonTree, given an input string.
decodeJSON :: String -> Either String [JsonTree]

-- | JsonTree is a tree that can be validated by Relapse.
type JsonTree = Tree Label
instance Parsers.Tree Json.JsonTree


-- | This module contains all the functions you need to implement a Relapse
--   expression.
module Expr

-- | Desc is the description of a function, especially built to make
--   comparisons of user defined expressions possible.
data Desc
Desc :: String -> String -> Int -> [Desc] -> Bool -> Desc
[_name] :: Desc -> String
[_toStr] :: Desc -> String
[_hash] :: Desc -> Int
[_params] :: Desc -> [Desc]
[_hasVar] :: Desc -> Bool

-- | mkDesc makes a description from a function name and a list of the
--   argument's descriptions.
mkDesc :: String -> [Desc] -> Desc

-- | AnyExpr is used by the Relapse parser to represent an Expression that
--   can return any type of value, where any is a predefined list of
--   possible types represented by AnyFunc.
data AnyExpr
AnyExpr :: Desc -> AnyFunc -> AnyExpr
[_desc] :: AnyExpr -> Desc
[_eval] :: AnyExpr -> AnyFunc

-- | AnyFunc is used by the Relapse parser and represents the list all
--   supported types of functions.
data AnyFunc
BoolFunc :: (Func Bool) -> AnyFunc
IntFunc :: (Func Int) -> AnyFunc
StringFunc :: (Func Text) -> AnyFunc
DoubleFunc :: (Func Double) -> AnyFunc
UintFunc :: (Func Word) -> AnyFunc
BytesFunc :: (Func ByteString) -> AnyFunc
BoolsFunc :: (Func [Bool]) -> AnyFunc
IntsFunc :: (Func [Int]) -> AnyFunc
StringsFunc :: (Func [Text]) -> AnyFunc
DoublesFunc :: (Func [Double]) -> AnyFunc
UintsFunc :: (Func [Word]) -> AnyFunc
ListOfBytesFunc :: (Func [ByteString]) -> AnyFunc

-- | Expr represents a user defined expression, which consists of a
--   description for comparisons and an evaluation function.
data Expr a
Expr :: Desc -> Func a -> Expr a
[desc] :: Expr a -> Desc
[eval] :: Expr a -> Func a

-- | Func represents the evaluation function part of a user defined
--   expression. This function takes a label from a tree parser and returns
--   a value or an error string.
type Func a = (Label -> Except String a)

-- | params returns the descriptions of the parameters of the user defined
--   expression.
params :: Expr a -> [Desc]

-- | name returns the name of the user defined expression.
name :: Expr a -> String

-- | hasVar returns whether the expression or any of its children contains
--   a variable expression.
hasVar :: Expr a -> Bool

-- | hashWithName calculates a hash of the function name and its
--   parameters.
hashWithName :: String -> [Desc] -> Int

-- | evalConst tries to evaluate a constant expression and either returns
--   the resulting constant value or nothing.
evalConst :: Expr a -> Maybe a

-- | isConst returns whether the input description is one of the six
--   possible constant values.
isConst :: Desc -> Bool

-- | assertArgs1 asserts that the list of arguments is only one argument
--   and returns the argument or an error message containing the function
--   name that was passed in as an argument to assertArgs1.
assertArgs1 :: String -> [AnyExpr] -> Except String AnyExpr

-- | assertArgs2 asserts that the list of arguments is only two arguments
--   and returns the two arguments or an error message containing the
--   function name that was passed in as an argument to assertArgs2.
assertArgs2 :: String -> [AnyExpr] -> Except String (AnyExpr, AnyExpr)

-- | mkBoolExpr generalises a bool expression to any expression.
mkBoolExpr :: Expr Bool -> AnyExpr

-- | mkIntExpr generalises an int expression to any expression.
mkIntExpr :: Expr Int -> AnyExpr

-- | mkStringExpr generalises a string expression to any expression.
mkStringExpr :: Expr Text -> AnyExpr

-- | mkDoubleExpr generalises a double expression to any expression.
mkDoubleExpr :: Expr Double -> AnyExpr

-- | mkBytesExpr generalises a bytes expression to any expression.
mkBytesExpr :: Expr ByteString -> AnyExpr

-- | mkUintExpr generalises a uint expression to any expression.
mkUintExpr :: Expr Word -> AnyExpr

-- | assertBool asserts that any expression is actually a bool expression.
assertBool :: AnyExpr -> Except String (Expr Bool)

-- | assertInt asserts that any expression is actually an int expression.
assertInt :: AnyExpr -> Except String (Expr Int)

-- | assertString asserts that any expression is actually a string
--   expression.
assertString :: AnyExpr -> Except String (Expr Text)

-- | assertDouble asserts that any expression is actually a double
--   expression.
assertDouble :: AnyExpr -> Except String (Expr Double)

-- | assertBytes asserts that any expression is actually a bytes
--   expression.
assertBytes :: AnyExpr -> Except String (Expr ByteString)

-- | assertUint asserts that any expression is actually a uint expression.
assertUint :: AnyExpr -> Except String (Expr Word)

-- | boolExpr creates a constant bool expression from a input value.
boolExpr :: Bool -> Expr Bool

-- | intExpr creates a constant int expression from a input value.
intExpr :: Int -> Expr Int

-- | stringExpr creates a constant string expression from a input value.
stringExpr :: Text -> Expr Text

-- | doubleExpr creates a constant double expression from a input value.
doubleExpr :: Double -> Expr Double

-- | bytesExpr creates a constant bytes expression from a input value.
bytesExpr :: ByteString -> Expr ByteString

-- | uintExpr creates a constant uint expression from a input value.
uintExpr :: Word -> Expr Word

-- | trimBool tries to reduce an expression to a single constant
--   expression, if it does not contain a variable.
trimBool :: Expr Bool -> Expr Bool

-- | trimInt tries to reduce an expression to a single constant expression,
--   if it does not contain a variable.
trimInt :: Expr Int -> Expr Int

-- | trimString tries to reduce an expression to a single constant
--   expression, if it does not contain a variable.
trimString :: Expr Text -> Expr Text

-- | trimDouble tries to reduce an expression to a single constant
--   expression, if it does not contain a variable.
trimDouble :: Expr Double -> Expr Double

-- | trimBytes tries to reduce an expression to a single constant
--   expression, if it does not contain a variable.
trimBytes :: Expr ByteString -> Expr ByteString

-- | trimUint tries to reduce an expression to a single constant
--   expression, if it does not contain a variable.
trimUint :: Expr Word -> Expr Word

-- | mkBoolsExpr generalises a list of bools expression to any expression.
mkBoolsExpr :: Expr [Bool] -> AnyExpr

-- | mkIntsExpr generalises a list of ints expression to any expression.
mkIntsExpr :: Expr [Int] -> AnyExpr

-- | mkStringsExpr generalises a list of strings expression to any
--   expression.
mkStringsExpr :: Expr [Text] -> AnyExpr

-- | mkDoublesExpr generalises a list of doubles expression to any
--   expression.
mkDoublesExpr :: Expr [Double] -> AnyExpr

-- | mkListOfBytesExpr generalises a list of bytes expression to any
--   expression.
mkListOfBytesExpr :: Expr [ByteString] -> AnyExpr

-- | mkUintsExpr generalises a list of uints expression to any expression.
mkUintsExpr :: Expr [Word] -> AnyExpr

-- | assertBools asserts that any expression is actually a list of bools
--   expression.
assertBools :: AnyExpr -> Except String (Expr [Bool])

-- | assertInts asserts that any expression is actually a list of ints
--   expression.
assertInts :: AnyExpr -> Except String (Expr [Int])

-- | assertStrings asserts that any expression is actually a list of
--   strings expression.
assertStrings :: AnyExpr -> Except String (Expr [Text])

-- | assertDoubles asserts that any expression is actually a list of
--   doubles expression.
assertDoubles :: AnyExpr -> Except String (Expr [Double])

-- | assertListOfBytes asserts that any expression is actually a list of
--   bytes expression.
assertListOfBytes :: AnyExpr -> Except String (Expr [ByteString])

-- | assertUints asserts that any expression is actually a list of uints
--   expression.
assertUints :: AnyExpr -> Except String (Expr [Word])

-- | boolsExpr sequences a list of expressions that each return a bool, to
--   a single expression that returns a list of bools.
boolsExpr :: [Expr Bool] -> Expr [Bool]

-- | intsExpr sequences a list of expressions that each return an int, to a
--   single expression that returns a list of ints.
intsExpr :: [Expr Int] -> Expr [Int]

-- | stringsExpr sequences a list of expressions that each return a string,
--   to a single expression that returns a list of strings.
stringsExpr :: [Expr Text] -> Expr [Text]

-- | doublesExpr sequences a list of expressions that each return a double,
--   to a single expression that returns a list of doubles.
doublesExpr :: [Expr Double] -> Expr [Double]

-- | listOfBytesExpr sequences a list of expressions that each return
--   bytes, to a single expression that returns a list of bytes.
listOfBytesExpr :: [Expr ByteString] -> Expr [ByteString]

-- | uintsExpr sequences a list of expressions that each return a uint, to
--   a single expression that returns a list of uints.
uintsExpr :: [Expr Word] -> Expr [Word]
instance GHC.Show.Show (Expr.Expr a)
instance GHC.Classes.Eq (Expr.Expr a)
instance GHC.Classes.Ord (Expr.Expr a)
instance GHC.Show.Show Expr.AnyExpr
instance GHC.Classes.Eq Expr.AnyExpr
instance GHC.Classes.Ord Expr.AnyExpr
instance GHC.Show.Show Expr.Desc
instance GHC.Classes.Ord Expr.Desc
instance GHC.Classes.Eq Expr.Desc


-- | This module contains all expressions for Relapse variables.
module Exprs.Var

-- | varBoolExpr creates a bool variable expression.
varBoolExpr :: Expr Bool

-- | varIntExpr creates an int variable expression.
varIntExpr :: Expr Int

-- | varUintExpr creates a uint variable expression.
varUintExpr :: Expr Word

-- | varDoubleExpr creates a double variable expression.
varDoubleExpr :: Expr Double

-- | varStringExpr creates a string variable expression.
varStringExpr :: Expr Text

-- | varBytesExpr creates a bytes variable expression.
varBytesExpr :: Expr ByteString

-- | isVar returns whether an expression is one of the six variable
--   expressions.
isVar :: Desc -> Bool


-- | This module contains the Relapse type expression.
module Exprs.Type

-- | mkTypeExpr is used by the parser to create a type expression for the
--   specific input type.
mkTypeExpr :: [AnyExpr] -> Except String AnyExpr

-- | typeExpr creates an expression that returns true if the containing
--   expression does not return an error. For example: `(typeExpr
--   varBoolExpr)` will ony return true is the field value is a bool.
typeExpr :: Expr a -> Expr Bool


-- | This module contains the Relapse string expressions.
module Exprs.Strings

-- | mkHasPrefixExpr dynamically creates a hasPrefix expression.
mkHasPrefixExpr :: [AnyExpr] -> Except String AnyExpr

-- | hasPrefixExpr creates a hasPrefix expression that returns true if the
--   second is a prefix of the first.
hasPrefixExpr :: Expr Text -> Expr Text -> Expr Bool

-- | mkHasSuffixExpr dynamically creates a hasSuffix expression.
mkHasSuffixExpr :: [AnyExpr] -> Except String AnyExpr

-- | hasSuffixExpr creates a hasSuffix expression that returns true if the
--   second is a suffix of the first.
hasSuffixExpr :: Expr Text -> Expr Text -> Expr Bool

-- | mkRegexExpr dynamically creates a regex expression.
mkRegexExpr :: [AnyExpr] -> Except String AnyExpr

-- | regexExpr creates a regex expression that returns true if the first
--   expression matches the second string.
regexExpr :: Expr Text -> Expr Text -> Expr Bool

-- | mkToLowerExpr dynamically creates a toLower expression.
mkToLowerExpr :: [AnyExpr] -> Except String AnyExpr

-- | toLowerExpr creates a toLower expression that converts the input
--   string to a lowercase string.
toLowerExpr :: Expr Text -> Expr Text

-- | mkToUpperExpr dynamically creates a toUpper expression.
mkToUpperExpr :: [AnyExpr] -> Except String AnyExpr

-- | toUpperExpr creates a toUpper expression that converts the input
--   string to an uppercase string.
toUpperExpr :: Expr Text -> Expr Text


-- | This module contains the Relapse logic expressions: not, and, or.
module Exprs.Logic

-- | mkNotExpr dynamically creates a not expression, if the single argument
--   is a bool expression.
mkNotExpr :: [AnyExpr] -> Except String AnyExpr

-- | notExpr creates a not expression, that returns true is the argument
--   expression returns an error or false.
notExpr :: Expr Bool -> Expr Bool

-- | mkAndExpr dynamically creates an and expression, if the two arguments
--   are both bool expressions.
mkAndExpr :: [AnyExpr] -> Except String AnyExpr

-- | andExpr creates an and expression that returns true if both arguments
--   are true.
andExpr :: Expr Bool -> Expr Bool -> Expr Bool

-- | mkOrExpr dynamically creates an or expression, if the two arguments
--   are both bool expressions.
mkOrExpr :: [AnyExpr] -> Except String AnyExpr

-- | orExpr creates an or expression that returns true if either argument
--   is true.
orExpr :: Expr Bool -> Expr Bool -> Expr Bool


-- | This module contains the Relapse length expressions.
module Exprs.Length

-- | mkLengthExpr dynamically creates a length expression, if the single
--   argument is a list, string or bytes.
mkLengthExpr :: [AnyExpr] -> Except String AnyExpr

-- | lengthListExpr creates a length expression, that returns the length of
--   a list.
lengthListExpr :: Expr [a] -> Expr Int

-- | lengthStringExpr creates a length expression, that returns the length
--   of a string.
lengthStringExpr :: Expr Text -> Expr Int

-- | lengthBytesExpr creates a length expression, that returns the length
--   of bytes.
lengthBytesExpr :: Expr ByteString -> Expr Int


-- | This module contains the Relapse elem expression.
module Exprs.Elem

-- | mkElemExpr dynamically creates an elem expression, if the first
--   argument is a list and the second an int index.
mkElemExpr :: [AnyExpr] -> Except String AnyExpr

-- | elemExpr creates an expression that returns an element from the list
--   at the specified index. Trimming this function would cause it to
--   become non generic. It is not necessary to trim each function, since
--   it is just an optimization.
elemExpr :: Expr [a] -> Expr Int -> Expr a


-- | This module contains the Relapse contains expressions.
module Exprs.Contains

-- | mkContainsExpr dynamically creates a contains expression, if the two
--   input types are:
--   
--   <ul>
--   <li>String and String where the second string is the possible
--   substring.</li>
--   <li>A List of :Strings, Ints or Uints paired with a String, Int or
--   Uint respectively.</li>
--   </ul>
mkContainsExpr :: [AnyExpr] -> Except String AnyExpr

-- | containsStringExpr creates a contains expression that returns true if
--   the second string is a substring of the first.
containsStringExpr :: Expr Text -> Expr Text -> Expr Bool

-- | containsExpr creates a contains expression that returns true if the
--   first argument is an element in the second list argument.
containsExpr :: (Eq a) => Expr a -> Expr [a] -> Expr Bool


-- | This module contains the Relapse compare expressions: equal, not
--   equal, greater than, greater than or equal, less than and less than or
--   equal.
module Exprs.Compare

-- | mkEqExpr dynamically creates an eq (equal) expression, if the two
--   input types are the same.
mkEqExpr :: [AnyExpr] -> Except String AnyExpr

-- | eqExpr creates an eq (equal) expression that returns true if the two
--   evaluated input expressions are equal and both don't evaluate to an
--   error.
eqExpr :: (Eq a) => Expr a -> Expr a -> Expr Bool

-- | mkNeExpr dynamically creates a ne (not equal) expression, if the two
--   input types are the same.
mkNeExpr :: [AnyExpr] -> Except String AnyExpr

-- | neExpr creates a ne (not equal) expression that returns true if the
--   two evaluated input expressions are not equal and both don't evaluate
--   to an error.
neExpr :: (Eq a) => Expr a -> Expr a -> Expr Bool

-- | mkGeExpr dynamically creates a ge (greater than or equal) expression,
--   if the two input types are the same.
mkGeExpr :: [AnyExpr] -> Except String AnyExpr

-- | geExpr creates a ge (greater than or equal) expression that returns
--   true if the first evaluated expression is greater than or equal to the
--   second and both don't evaluate to an error.
geExpr :: (Ord a) => Expr a -> Expr a -> Expr Bool

-- | mkLeExpr dynamically creates a le (less than or equal) expression, if
--   the two input types are the same.
mkLeExpr :: [AnyExpr] -> Except String AnyExpr

-- | leExpr creates a le (less than or equal) expression that returns true
--   if the first evaluated expression is less than or equal to the second
--   and both don't evaluate to an error.
leExpr :: (Ord a) => Expr a -> Expr a -> Expr Bool

-- | mkGtExpr dynamically creates a gt (greater than) expression, if the
--   two input types are the same.
mkGtExpr :: [AnyExpr] -> Except String AnyExpr

-- | gtExpr creates a gt (greater than) expression that returns true if the
--   first evaluated expression is greater than the second and both don't
--   evaluate to an error.
gtExpr :: (Ord a) => Expr a -> Expr a -> Expr Bool

-- | mkLtExpr dynamically creates a lt (less than) expression, if the two
--   input types are the same.
mkLtExpr :: [AnyExpr] -> Except String AnyExpr

-- | ltExpr creates a lt (less than) expression that returns true if the
--   first evaluated expression is less than the second and both don't
--   evaluate to an error.
ltExpr :: (Ord a) => Expr a -> Expr a -> Expr Bool


-- | This module contains the standard library of expressions, used by the
--   Relapse parser.
module Exprs

-- | mkBuiltIn parsers a builtin function to a relapse expression.
mkBuiltIn :: String -> AnyExpr -> Except String AnyExpr

-- | mkExpr is a grouping of all the standard library functions as one
--   MkFunc.
mkExpr :: String -> [AnyExpr] -> Except String AnyExpr

-- | MkFunc is used by the parser to create a function from a name and
--   arguments.
type MkFunc = String -> [AnyExpr] -> Except String AnyExpr

-- | stdOnly contains no functions, which means that when it is combined
--   (in Relapse parser) with mkExpr the parser will have access to only
--   the standard library.
stdOnly :: String -> [AnyExpr] -> Except String AnyExpr


-- | This module describes the patterns supported by Relapse.
--   
--   It also contains some simple functions for the map of references that
--   a Relapse grammar consists of.
--   
--   Finally it also contains some very simple pattern functions.
module Patterns

-- | Pattern recursively describes a Relapse Pattern.
data Pattern
Empty :: Pattern
ZAny :: Pattern
Node :: (Expr Bool) -> Pattern -> Pattern
Or :: Pattern -> Pattern -> Pattern
And :: Pattern -> Pattern -> Pattern
Not :: Pattern -> Pattern
Concat :: Pattern -> Pattern -> Pattern
Interleave :: Pattern -> Pattern -> Pattern
ZeroOrMore :: Pattern -> Pattern
Optional :: Pattern -> Pattern
Contains :: Pattern -> Pattern
Reference :: String -> Pattern

-- | Refs is a map from reference name to pattern and describes a relapse
--   grammar.
data Refs

-- | emptyRef returns an empty reference map.
emptyRef :: Refs

-- | union returns the union of two reference maps.
union :: Refs -> Refs -> Refs

-- | newRef returns a new reference map given a single pattern and its
--   reference name.
newRef :: String -> Pattern -> Refs

-- | reverseLookupRef returns the reference name for a given pattern.
reverseLookupRef :: Pattern -> Refs -> Maybe String

-- | lookupRef looks up a pattern in the reference map, given a reference
--   name.
lookupRef :: Refs -> String -> Pattern

-- | hasRecursion returns whether an relapse grammar has any recursion,
--   starting from the "main" reference.
hasRecursion :: Refs -> Bool

-- | The nullable function returns whether a pattern is nullable. This
--   means that the pattern matches the empty string.
nullable :: Refs -> Pattern -> Bool

-- | unescapable is used for short circuiting. A part of the tree can be
--   skipped if all patterns are unescapable.
unescapable :: Pattern -> Bool
instance GHC.Classes.Eq Patterns.Refs
instance GHC.Show.Show Patterns.Refs
instance GHC.Show.Show Patterns.Pattern
instance GHC.Classes.Ord Patterns.Pattern
instance GHC.Classes.Eq Patterns.Pattern


-- | This module parses the Relapse Grammar using the Parsec Library.
module Parser

-- | parseGrammar parses the Relapse Grammar.
parseGrammar :: String -> Either ParseError Refs

-- | parseGrammarWithUDFs parses the Relapse Grammar with extra user
--   defined functions.
parseGrammarWithUDFs :: MkFunc -> String -> Either ParseError Refs

-- | For internal testing
grammar :: MkFunc -> CharParser () Refs

-- | For internal testing
pattern :: MkFunc -> CharParser () Pattern

-- | For internal testing
nameExpr :: CharParser () (Expr Bool)

-- | For internal testing
expr :: MkFunc -> CharParser () (Expr Bool)

-- | For internal testing
idLit :: CharParser () String

-- | For internal testing
bytesCastLit :: CharParser () ByteString

-- | For internal testing
stringLit :: CharParser () Text

-- | For internal testing
doubleCastLit :: CharParser () Double

-- | For internal testing
uintCastLit :: CharParser () Word

-- | For internal testing
intLit :: CharParser () Int

-- | For internal testing
ws :: CharParser () ()


-- | This module simplifies Relapse patterns.
module Simplify

-- | simplify simplifies an input pattern to an equivalent simpler pattern.
simplify :: Refs -> Pattern -> Pattern


-- | This module contains the XML Parser.
module Xml

-- | decodeXML returns a XmlTree, given an input string.
decodeXML :: String -> [XmlTree]
instance Parsers.Tree Text.XML.HXT.DOM.TypeDefs.XmlTree


-- | This is an internal relapse module.
--   
--   It zips patterns to reduce the state space.
module Zip

-- | Zipper represents compressed indexes that resulted from compressing a
--   list of patterns. This can be used to uncompress a list of bools
--   (nullability of patterns).
data Zipper

-- | zippy compresses a list of patterns.
zippy :: [Pattern] -> ([Pattern], Zipper)

-- | unzipby uncompresses a list of bools (nullability of patterns).
unzipby :: Zipper -> [Bool] -> [Bool]
instance GHC.Classes.Ord Zip.Zipper
instance GHC.Classes.Eq Zip.Zipper
instance GHC.Classes.Ord Zip.ZipEntry
instance GHC.Classes.Eq Zip.ZipEntry


-- | This is an internal relapse module.
--   
--   It contains multiple implementations of if expressions.
module IfExprs

-- | IfExprs is a tree of if expressions, which contains a list of
--   resulting patterns on each of its leaves.
data IfExprs

-- | IfExpr contains a condition and a return pattern for each of the two
--   cases.
data IfExpr

-- | newIfExpr creates an IfExpr.
newIfExpr :: Expr Bool -> Pattern -> Pattern -> IfExpr

-- | valIfExprs evaluates a tree of if expressions and returns the
--   resulting patterns or an error.
evalIfExprs :: IfExprs -> Label -> Except String [Pattern]

-- | compileIfExprs compiles a list of if expressions in an IfExprs tree,
--   for efficient evaluation.
compileIfExprs :: Refs -> [IfExpr] -> IfExprs

-- | ZippedIfExprs is a tree of if expressions, but with a zipped pattern
--   list and a zipper on each of the leaves.
data ZippedIfExprs

-- | zipIfExprs compresses an if expression tree's leaves.
zipIfExprs :: IfExprs -> ZippedIfExprs

-- | evalZippedIfExprs evaulates a ZippedIfExprs tree and returns the
--   zipped pattern list and zipper from the resulting leaf.
evalZippedIfExprs :: ZippedIfExprs -> Label -> Except String ([Pattern], Zipper)


-- | This module is a simple implementation of the internal derivative
--   algorithm.
--   
--   It is intended to be used for explanation purposes.
--   
--   This means that it gives up speed for readability.
--   
--   Thus it has no type of memoization.
module Derive

-- | derive is the classic derivative implementation for trees.
derive :: Tree t => Refs -> [t] -> Except String Pattern

-- | calls returns a compiled if expression tree. Each if expression
--   returns a child pattern, given the input value. In other words calls
--   signature is actually:
--   
--   <pre>
--   Refs -&gt; [Pattern] -&gt; Value -&gt; [Pattern]
--   </pre>
--   
--   , where the resulting list of patterns are the child patterns, that
--   need to be derived given the trees child values.
calls :: Refs -> [Pattern] -> IfExprs

-- | returns takes a list of patterns and list of bools. The list of bools
--   represent the nullability of the derived child patterns. Each bool
--   will then replace each Node pattern with either an Empty or EmptySet.
--   The lists do not to be the same length, because each Pattern can
--   contain an arbitrary number of Node Patterns.
returns :: Refs -> ([Pattern], [Bool]) -> [Pattern]

-- | zipderive is a slighty optimized version of derivs. It zips its
--   intermediate pattern lists to reduce the state space.
zipderive :: Tree t => Refs -> [t] -> Except String Pattern


-- | This module contains a VPA (Visual Pushdown Automaton) implementation
--   of the internal derivative algorithm.
--   
--   It is intended to be used for explanation purposes.
--   
--   It shows how out algorithm is effective equivalent to a visual
--   pushdown automaton.
module VpaDerive

-- | derive is the derivative implementation for trees. This implementation
--   makes use of visual pushdown automata.
derive :: Tree t => Refs -> [t] -> Except String Pattern


-- | This module is an efficient implementation of the derivative algorithm
--   for trees.
--   
--   It is intended to be used for production purposes.
--   
--   This means that it gives up some readability for speed.
--   
--   This module provides memoization of the nullable, calls and returns
--   functions.
module MemDerive

-- | derive is the classic derivative implementation for trees.
derive :: Tree t => Refs -> [t] -> Except String Pattern

-- | Mem is the object used to store memoized results of the nullable,
--   calls and returns functions.
data Mem

-- | newMem creates a object used for memoization by the validate function.
--   Each grammar should create its own memoize object.
newMem :: Mem

-- | nullable returns whether a pattern is nullable and memoizes the
--   results.
nullable :: Refs -> Pattern -> State Mem Bool

-- | validate is the uses the derivative implementation for trees and
--   return whether tree is valid, given the input grammar and start
--   pattern.
validate :: Tree t => Refs -> Pattern -> [t] -> (State Mem) Bool


-- | This module provides an implementation of the relapse validation
--   language.
--   
--   Relapse is intended to be used for validation of trees or filtering of
--   lists of trees.
--   
--   Katydid currently provides two types of trees out of the box: Json and
--   XML, but relapse supports any type of tree as long the type is of the
--   Tree typeclass provided by the Parsers module.
--   
--   The validate and filter functions expects a Tree to be a list of
--   trees, since not all serialization formats have a single root. For
--   example, valid json like "[1, 2]" does not have a single root. Relapse
--   can also validate these types of trees. If your tree has a single
--   root, simply provide a singleton list as input.
module Relapse

-- | parseGrammar parses the relapse grammar and returns either a parsed
--   grammar (Refs, for the list of references) or an error string.
parseGrammar :: String -> Except String Refs

-- | parseGrammarWithUDFs parses the relapse grammar with extra user
--   defined functions and returns either a parsed grammar (Refs, for the
--   list of references) or an error string.
parseGrammarWithUDFs :: MkFunc -> String -> Except String Refs

-- | validate returns whether a tree is valid, given the grammar (Refs).
validate :: Tree t => Refs -> [t] -> Bool

-- | filter returns a filtered list of trees, given the grammar (Refs).
filter :: Tree t => Refs -> [[t]] -> [[t]]
