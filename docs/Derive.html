<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Derive</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Derive.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">katydid-0.3.0.0: A haskell implementation of Katydid</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Derive</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module is a simple implementation of the internal derivative algorithm.</p><p>It is intended to be used for explanation purposes.</p><p>This means that it gives up speed for readability.</p><p>Thus it has no type of memoization.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:derive">derive</a> :: <a href="Parsers.html#t:Tree">Tree</a> t =&gt; <a href="Patterns.html#t:Refs">Refs</a> -&gt; [t] -&gt; <a href="../mtl-2.2.1/Control-Monad-Except.html#t:Except">Except</a> <a href="../base-4.10.0.0/Data-String.html#t:String">String</a> <a href="Patterns.html#t:Pattern">Pattern</a></li><li class="src short"><a href="#v:calls">calls</a> :: <a href="Patterns.html#t:Refs">Refs</a> -&gt; [<a href="Patterns.html#t:Pattern">Pattern</a>] -&gt; <a href="IfExprs.html#t:IfExprs">IfExprs</a></li><li class="src short"><a href="#v:returns">returns</a> :: <a href="Patterns.html#t:Refs">Refs</a> -&gt; ([<a href="Patterns.html#t:Pattern">Pattern</a>], [<a href="../base-4.10.0.0/Data-Bool.html#t:Bool">Bool</a>]) -&gt; [<a href="Patterns.html#t:Pattern">Pattern</a>]</li><li class="src short"><a href="#v:zipderive">zipderive</a> :: <a href="Parsers.html#t:Tree">Tree</a> t =&gt; <a href="Patterns.html#t:Refs">Refs</a> -&gt; [t] -&gt; <a href="../mtl-2.2.1/Control-Monad-Except.html#t:Except">Except</a> <a href="../base-4.10.0.0/Data-String.html#t:String">String</a> <a href="Patterns.html#t:Pattern">Pattern</a></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:derive" class="def">derive</a> :: <a href="Parsers.html#t:Tree">Tree</a> t =&gt; <a href="Patterns.html#t:Refs">Refs</a> -&gt; [t] -&gt; <a href="../mtl-2.2.1/Control-Monad-Except.html#t:Except">Except</a> <a href="../base-4.10.0.0/Data-String.html#t:String">String</a> <a href="Patterns.html#t:Pattern">Pattern</a> <a href="src/Derive.html#derive" class="link">Source</a> <a href="#v:derive" class="selflink">#</a></p><div class="doc"><p>derive is the classic derivative implementation for trees.</p></div></div><div class="top"><p class="src"><a id="v:calls" class="def">calls</a> :: <a href="Patterns.html#t:Refs">Refs</a> -&gt; [<a href="Patterns.html#t:Pattern">Pattern</a>] -&gt; <a href="IfExprs.html#t:IfExprs">IfExprs</a> <a href="src/Derive.html#calls" class="link">Source</a> <a href="#v:calls" class="selflink">#</a></p><div class="doc"><p>calls returns a compiled if expression tree.
 Each if expression returns a child pattern, given the input value.
 In other words calls signature is actually:</p><pre>  Refs -&gt; [Pattern] -&gt; Value -&gt; [Pattern]
</pre><p>, where the resulting list of patterns are the child patterns,
 that need to be derived given the trees child values.</p></div></div><div class="top"><p class="src"><a id="v:returns" class="def">returns</a> :: <a href="Patterns.html#t:Refs">Refs</a> -&gt; ([<a href="Patterns.html#t:Pattern">Pattern</a>], [<a href="../base-4.10.0.0/Data-Bool.html#t:Bool">Bool</a>]) -&gt; [<a href="Patterns.html#t:Pattern">Pattern</a>] <a href="src/Derive.html#returns" class="link">Source</a> <a href="#v:returns" class="selflink">#</a></p><div class="doc"><p>returns takes a list of patterns and list of bools.
 The list of bools represent the nullability of the derived child patterns.
 Each bool will then replace each Node pattern with either an Empty or EmptySet.
 The lists do not to be the same length, because each Pattern can contain an arbitrary number of Node Patterns.</p></div></div><div class="top"><p class="src"><a id="v:zipderive" class="def">zipderive</a> :: <a href="Parsers.html#t:Tree">Tree</a> t =&gt; <a href="Patterns.html#t:Refs">Refs</a> -&gt; [t] -&gt; <a href="../mtl-2.2.1/Control-Monad-Except.html#t:Except">Except</a> <a href="../base-4.10.0.0/Data-String.html#t:String">String</a> <a href="Patterns.html#t:Pattern">Pattern</a> <a href="src/Derive.html#zipderive" class="link">Source</a> <a href="#v:zipderive" class="selflink">#</a></p><div class="doc"><p>zipderive is a slighty optimized version of derivs.
 It zips its intermediate pattern lists to reduce the state space.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>